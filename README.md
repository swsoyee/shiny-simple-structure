# 别再让你的 Shiny 代码源文件乱成一团了

![](www/%E5%B9%BB%E7%81%AF%E7%89%872.jpeg)

对于很多 R 用户来说，用户的背景都是更偏向于学术方面的，
所以对于 **应用开发** 这种较为软件工程方面知识不是特别熟悉。
但是由于 Shiny 框架的出现，大大方便了 R 用户可以不用花费大量时间在学习网页开发的前后端上面，
就能快速的搭建具有一定可用性的网页应用。

![](www/%E5%B9%BB%E7%81%AF%E7%89%873.jpeg)

虽然和互联网应用开发的主流框架来比，Shiny 在排行榜上根本排不上号，
但至少它的出现，让更多的R用户拥有把自己的研究成果 以一个门槛较低的方式得到了更好的展示。

你想，假设发表成果的时候都是R包，或者全是分析用的一大串源码，
那么对于部分代码能力没那么强的刚入门没多久的人来说，很有可能基本就是在看天书。
如果运行甚至是安装的时候代码报了一两个错，那他可以说是根本就不知道该怎么去解决。

但是，如果你提供了一个网页页面工具的话，在浏览器上直接打开链接，开箱即用，
那么你的成果有了一个易用的界面的话，自然而然能够获得更多的关注。

![](www/%E5%B9%BB%E7%81%AF%E7%89%874.jpeg)

由于上手门槛低，我们都能在网上找到大量 Shiny 应用。
但一个问题是，我们很容易发现，
很多有不错想法的应用，由于得不到良好的可持续开发的机会，
导致这些应用大多停留在了较为基础的状态，没有什么迭代。

至于为什么会出现大量的半成品工具，根据个人的经验可能有这么几个原因：

很多项目其实都是一些学生或者研究者主要在构思核心算法或者整合资源的时候，顺手开发的一个页面工具。
由于缺少经验，应用整体的架构其实也是边学边写，整体意识稍微欠缺，
就容易导致整个应用代码特别容易成为所谓的屎山。

其次，由于项目开发人员很多时候都是研究室里的一个或者两个学生，当他们毕业后，
即使后辈或者是同行想接着改进，也发现根本看不懂该从哪里下手，最后只能不了了之。

甚至是本人自己开发的应用，隔一阵子回去看，发现连自己都不知道怎么改了。

所以在做开发时，即使经验不是很丰富，或者是初学者，最好也要有一个对于源代码文件进行管理的意识。
最好做到在写每一行代码的时候都要想一想，如果是自己以外的人看到这一行的时候，他能不能理解，

这样的话不仅易于后期维护，也能让你的应用时刻保有持续扩展的可能性。

比如说你把你的应用开源的话，每块功能的实现代码都写得非常清晰的情况下，只要辅助少数的注释内容，
别人就可以仅从阅读你的代码就能理解它的工作流程，甚至为它进行完善，实现新的功能。

这里稍微说一下两个能够帮助你养成良好代码习惯的包 `{lintr}` 和 `{styler}`，前者是用来对你的代码进行书写上的格式规范，后者是代码样式格式化的包。
这里就不拓展来讲了，感兴趣的可以搜索学习即可。

![](www/%E5%B9%BB%E7%81%AF%E7%89%876.jpeg)

那么另一方面我们应该如何入手去学习这种源代码文件的管理呢？

这里先简要介绍一下两个工业化的Shiny应用的开发框架。
一个是发展已经有了一定年头的 `{golem}` ，由 ThinkR 这个组织开发和维护

另一个是半年前由 Appsilon 这个公司进行开发和维护的 `{rhino}`

`{golem}` 由于发展时间较久，因此可以参考学习的应用也较多，
它们的团队写的《Engineering Production-Grade Shiny Apps》这一本书中也有较为详细的使用说明可以参考学习。

而 `{rhino}` 比较新，所以如果没有一定的 Shiny 开发和前端开发的经验的话，
在初期可能理解起来较为吃力，需要花费不少功夫。但是文档教程之类的肯定随着时间越来越多。

`{golem}` 由于设计时间较早，其架构更偏向于在纯粹的Shiny和R包开发中，加入了一些工程方面的思想在里面。
而 `{rhino}` 的话与现代化的前端开发结合得更为紧密。

![](www/%E5%B9%BB%E7%81%AF%E7%89%878.jpeg)

而它们各自的特点我们也能够在它们对应用所要求的结构中能看出来。

`{golem}` 的一级结构基本和 R 包开发非常类似，有 R 包里面的 DESCRIPTION，NAMESPACE，inst，man 文件夹等。
而 `{rhino}` 这边就和前端应用的结构类似了。
一级结构有源代码的 app，然后还有 tests 文件夹，tests 还使用了 cypress 测试框架。
可以知道其对 Node.js 和 JavaScript 具有较大程度的依赖的。

不过在 R 代码部分的开发方面，它们也都有同样的特点，
都采用了较为进阶的基于 Shiny module 模块化的方式进行开发。

对于上述的两个框架，无论选择哪一个，
都可以帮助你更为快速的搭建一个具有工业级设计在内的 Shiny 应用。

但同时，对于 Shiny 开发经验还不够丰富的人来说，两者都具有一定的学习难度的。
`{golem}` 的话至少要理解 Shiny 模块，应用运维方面的知识。
而 `{rhino}` 的话甚至还要学习测试和前端方面的相关知识。

如果是有稳定的多人团队来开发的情况下，多花点时间来学习我认为也是很划得来的。
我也强烈建议如果想写出好的作品的话，可以抽空了解一下，这样的话能够减少未来会发生的各种技术负债，防患于未然。

但很多时候每个应用可能都只是由一个小团队甚至是一个人弄完全套流程的。
那么这个时候可能就有种用牛刀来杀鸡的感觉了。

![](www/%E5%B9%BB%E7%81%AF%E7%89%879.jpeg)

所以在这里，结合自己已经开发过不少 Shiny 应用的经验，
分享自己的一种源码管理的方式。以最小的学习代价来进行管理，相当于帮入门没多久的开发者搭座桥，快速跨过这一阶段，便于以后更为快速地掌握之前提到的牛刀。

至于以后不管是开发大型或小型应用，选择 `{golem}` 或者是 `{rhino}`，甚至是提出自己的框架全由你来选择。

由于本次介绍主要是面向初学者的，很多内容不做介绍，仅仅对应用本身的代码文件分组做一些简要的分类，不涉及高深的知识模块。
因此如果正好你手头也有 Shiny 应用，又不知道如何整理代码的话，
可以稍作参考，以便于日后进行拓展和维护。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8710.jpeg)

我本人常用的管理方法大致可以归纳有以下的结构。
在根目录下 app 文件夹包含了整个应用的所有模块的源代码，
如果有用 `{renv}` 来管理依赖的话就会有 renv 文件夹和 renv.lock 文件，
这里的话是和 `{rhino}` 是类似的。
`{renv}` 这个包的用法就不在这里扩展说明了，简单的说就是对你的整个应用开发和运行，
对需要到的所有外部依赖包的版本和来源都做一个记录的管理器
这样当你的应用有迁移，或者是多人开发的时候能很方便的保持各种依赖的版本一致，减少由于版本不同带来的各种潜在 bug 的影响。

在根目录下还有 app.R 和 dependencies.R 这两个单独的文件，
dependencies 主要用来加载整个 app 运行所需要的包，就分开便于查看。
而 app.R 就是大家最熟悉的主要用来连接 ui 和 server 的启动器了。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8711.jpeg)

主要介绍一下 app.R 里面的内容。
首先自然是加载所需要的所有包的 dependences，
然后紧接着是读取一个在 app 文件夹下的 global 文件。

你可以在这个 global 文件里保存一些应用整体运行中所需要的全局变量和函数等。
然后就是 ui 变量。一个常见的 dashboard 页面的 ui 一般都会有 header，sidebar 和 body 等，
我这里用的是 `{bs4dash}` 这个仪表盘界面包来进行演示的，别的界面包也基本上都是一样的写法。

Header 和 sidebar 一般都不会特别复杂，因此都写在 app.R 里也不会太难看。

而 body 这一块就是当你点击左侧菜单时所出现的主界面了。
而主界面一般内容都不少，因此可以把每个页面都分离到了一个放在了 layout/view.R 里了。

然后为了减少一些重复代码便于阅读，可以写了一个 load.ui 函数进行加载。
至于这个 layout 的文件夹结构我们稍后再讲。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8712.jpeg)

到了 server 这边就简单多了。
为了让自定义的全局变量和函数都能在 server 里应用，我们在这里也需要再加载一次 global，
否则它们并不会进入到运行中的 shiny 服务中，会出现找不到的错误。

剩下的只需要把我们写保存了的各种 output 的源码用自制的 load.file 加载一下就行。
至于是采用清楚记录每一个加载文件的方法一，
还是把 app 里页面相关的 output 文件一次性加载的话，
就各有优劣，我个人的话比较喜欢方法一的按需加载，
比较可控。

app.R 里面的内容大致就是这样，接下来我们继续看一下 app 里面的各种文件夹是怎么区分的。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8713.jpeg)

接下来我们主要关注一下 pages 里面的文件夹结构。
pages 就是存放所有应用 ui 和 server 等和 shiny 相关文件的顶层文件夹。
然后每有一个页面就可以创建一个单独的文件夹，比如我这里就示例了有一个叫 page_one 的界面，所以就创建了page_one 文件夹用于保存这个页面所有相关的源码文件。

而 layout 文件夹就是该页面的主要布局文件。如果你每个页面的内容不多，那么一个单文件 view.R 可能就足够了。如果你也页面还有很多子标签，或者是一个 box 里面有很多 tab，然后 box 也有好几个的情况下还可以将view.R 再细分。

Data/ 主要就是页面中会用到的数据集，并且用 reactive 方法包装一下，
方便需要实时反应的元件的使用。

然后就是 dynamic_ui。这里主要保存一些需要动态生成的 UI 类的输出方法。
比如说有一个下拉菜单，但是菜单里面的选项是会变化的时候，就需要这种对 UI 输入元件进行生成了。

Plot 和 table 自然而然就来保存 shiny 应用中用于展示的大量图表类输出了。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8714.jpeg)

在这里我也根据这套管理方法做了一个小的 demo（这个 repository ），
主要用到的开发包就是整体框架的 `{bs4Dash}` ，数据处理可以考虑用 `{data.table}`，还有一个用来扩展可用的输入元件的 `{shinyWidgets}`，绘图用的是 `{echarts4r}`，表格类就用的是 `{reactable}`。

这一套在我看来属于受众较广，又能凭借低学习成本，拥有快速开发一个较为现代化仪表盘应用能力的一套组合拳了。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8715.jpeg)

最后再来回顾一下整体的文件夹结构，并且追加一点新的内容。
对于每个页面，我们的 pages 文件夹里面就有一个独立属于该页面的文件夹。

utils 文件夹主要保存一些即使脱离了 shiny，也能够单独使用的函数等。

除了 utils，在同级下你还可以设一些别的能够做归类的文件夹。
比如存储数据集的 data，一些全局都会用到的比如默认的图表主题的设定的 config 文件夹等。
这里就可以根据需要自己增减了。

然后我这里在 root 下还加了一个 bin 文件夹。这个文件夹主要就是储存独立于 shiny 外的可执行脚本。
比如你的应用需要从别的地方获取原始数据的话，那么你也没必要把数据的处理流程放到应用里，
你可以在 bin 下写些数据的获取、清洗、基础变换等的一些脚本。
这样如果你的数据不需要实时更新的时候就可以做这种分离，从而提高你的应用对数据展示的效率。

最后就是比较常见的 www 文件夹了。这里主要保存网页所需的一些非 R 相关的文件。
比如图片，样式文件，JavaScript 脚本等。
当然最好的做法是把 www 放到 app 里去，不过要记得更改一下默认路径才能访问到。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8716.jpeg)

最后再稍微延展一下，俗话说无规矩，不成方圆。
除了文件夹的结构外，还有一些平时需要稍微注意的点。
这里的只是最基础的几点，如果一下子列一大堆条条框框也不容易消化。

首先要注意的是，尽量做到 pages 下由 server 使用的文件仅包含一个输出元件，也就是 output。
这虽然会导致文件数目的增加，但这恰恰也是方便日后维护的一个好习惯。
要不然当应用功能逐步增加的时候，然后你也远离了这个项目一阵子，之后回头再一看得看老半天才能搞明白这块到底是怎么串起来，很消耗精力。

同理，第二第三点的采取下划线命名法，和输出元件的名称和文件名保持一致的要求同样是为了便于维护。

最后一点就是要对自己写的代码进行风格检查和自动整理，比如该换行的地方没换行，空格多一个少一个，一会儿用单引号一会双引号的。
对于非程序员来说可能觉得这个无关紧要，但这一点其实就和一个人的字迹一样，字写得好看的人大家潜意识都会认为这个人很有水平，写得规范好看的代码也会给人带来一种作者很靠谱的印象。

只要看一下高手开发的知名包的源码，他们的风格即使稍有不同，但在同一个包内都有统一的规范。
并不是说他们会对每一行每一个字都仔仔细细的在抠，是因为他们用了合适的工具来进行自动化管理，
不符合规定的代码机器会自动修改，改不了的会告诉他们，然后再修改就行。

代码规范了，不仅看得舒服，也容易理解，
社区用户也会认为你的东西靠谱，然后乐于给你提出修改意见，甚至在 你的规范 下替你修bug或者加新的功能。

![](www/%E5%B9%BB%E7%81%AF%E7%89%8717.jpeg)
